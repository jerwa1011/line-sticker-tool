<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sticker Master V13.5 - ç¶“å…¸å›æ­¸ç‰ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&family=Mochiy+Pop+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; overflow: hidden; background-color: #111827; color: white; }
        
        /* ç¶“å…¸æŒ‰éˆ•æ¨£å¼ */
        .tool-btn { 
            @apply w-12 h-12 mb-2 rounded-lg border border-gray-600 flex flex-col items-center justify-center text-xs text-gray-400 hover:bg-gray-700 transition;
        }
        .tool-btn.active { 
            @apply bg-blue-600 text-white border-blue-500;
        }

        /* ç•«å¸ƒå€åŸŸèƒŒæ™¯ (æ£‹ç›¤æ ¼) */
        #canvas-area {
            background-color: #252525;
            background-image: 
                linear-gradient(45deg, #333 25%, transparent 25%), 
                linear-gradient(-45deg, #333 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #333 75%), 
                linear-gradient(-45deg, transparent 75%, #333 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            position: relative;
            flex: 1;
            overflow: hidden; /* ç¢ºä¿ç•«å¸ƒä¸æœƒæ’é–‹ç‰ˆé¢ */
        }

        /* æµ®å‹•é¸å–® (ä¿ç•™å¥½ç”¨çš„æµ®å‹•åˆªé™¤) */
        #floating-menu {
            display: none; position: absolute; z-index: 100;
            padding: 5px; gap: 5px; border-radius: 8px;
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid #4b5563;
            transform: translate(-50%, -120%);
        }
        .float-btn {
            width: 30px; height: 30px; border-radius: 4px; 
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; color: #d1d5db;
        }
        .float-btn:hover { background-color: #4b5563; color: white; }

        input[type="range"] { @apply accent-blue-500 cursor-pointer; }
    </style>
</head>
<body class="h-screen flex flex-col" oncontextmenu="return false;">

    <header class="h-14 bg-gray-800 border-b border-gray-700 flex items-center justify-between px-4 shrink-0 z-20">
        <div class="flex items-center gap-3">
            <span class="text-2xl">ğŸ› ï¸</span>
            <h1 class="font-bold text-lg">è²¼åœ–å¤§å¸« <span class="text-xs text-gray-400 bg-gray-700 px-2 py-1 rounded">Classic</span></h1>
        </div>
        
        <div class="flex items-center gap-2">
            <button onclick="undo()" class="bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded text-sm disabled:opacity-30"><i class="fas fa-undo"></i></button>
            <button onclick="redo()" class="bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded text-sm disabled:opacity-30"><i class="fas fa-redo"></i></button>
            <div class="w-[1px] h-6 bg-gray-600 mx-2"></div>
            <label class="cursor-pointer bg-blue-600 hover:bg-blue-500 px-4 py-1.5 rounded text-sm font-bold flex items-center gap-2">
                <i class="fas fa-folder-open"></i> è¼‰å…¥
                <input type="file" id="imgLoader" accept="image/*" class="hidden">
            </label>
            <button onclick="downloadImage()" class="bg-green-600 hover:bg-green-500 px-4 py-1.5 rounded text-sm font-bold flex items-center gap-2">
                <i class="fas fa-download"></i> è¼¸å‡º
            </button>
        </div>
    </header>

    <div class="flex-1 flex overflow-hidden">
        
        <div class="w-16 bg-gray-800 border-r border-gray-700 flex flex-col items-center py-4 shrink-0 overflow-y-auto">
            <button onclick="setMode('select')" id="btn-select" class="tool-btn active"><i class="fas fa-mouse-pointer text-lg"></i><span>é¸å–</span></button>
            <button onclick="setMode('pan')" id="btn-pan" class="tool-btn"><i class="fas fa-hand-paper text-lg"></i><span>ç§»å‹•</span></button>
            <div class="w-8 h-[1px] bg-gray-600 my-2"></div>
            <button onclick="addText()" class="tool-btn text-yellow-400 border-yellow-700"><i class="fas fa-font text-lg"></i><span>æ–‡å­—</span></button>
            <button onclick="setMode('draw')" id="btn-draw" class="tool-btn"><i class="fas fa-pen text-lg"></i><span>ç•«ç­†</span></button>
            <button onclick="setMode('eraser')" id="btn-eraser" class="tool-btn text-red-400 border-red-800"><i class="fas fa-eraser text-lg"></i><span>æ“¦é™¤</span></button>
            <div class="w-8 h-[1px] bg-gray-600 my-2"></div>
            <button onclick="deleteActiveObject()" class="tool-btn text-red-500 hover:bg-red-900/30"><i class="fas fa-trash-alt text-lg"></i><span>åˆªé™¤</span></button>
            <button onclick="startCrop()" id="btn-crop" class="tool-btn"><i class="fas fa-crop-alt text-lg"></i><span>è£åˆ‡</span></button>
        </div>

        <div id="canvas-area">
            <canvas id="c"></canvas>

            <div id="floating-menu">
                <div class="float-btn bg-red-600 text-white" onclick="deleteActiveObject()"><i class="fas fa-trash"></i></div>
                <div class="float-btn" onclick="toggleLock()" id="float-lock"><i class="fas fa-unlock"></i></div>
                <div class="float-btn" onclick="duplicateObject()"><i class="fas fa-clone"></i></div>
                <div class="float-btn" onclick="groupObjects()" id="float-group"><i class="fas fa-object-group"></i></div>
                <div class="float-btn" onclick="ungroupObjects()" id="float-ungroup"><i class="fas fa-object-ungroup"></i></div>
                <div class="float-btn" onclick="bringToFront()"><i class="fas fa-arrow-up"></i></div>
                <div class="float-btn" onclick="sendToBack()"><i class="fas fa-arrow-down"></i></div>
            </div>

            <div class="absolute bottom-4 right-4 bg-gray-800 p-2 rounded shadow flex items-center gap-2 border border-gray-600">
                <button onclick="zoomToFit()" class="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded" title="é©æ‡‰è¦–çª—"><i class="fas fa-expand"></i></button>
                <button onclick="resetViewport()" class="text-xs bg-gray-700 hover:bg-gray-600 px-2 py-1 rounded" id="zoom-val">100%</button>
            </div>

            <div id="crop-controls" class="absolute bottom-16 left-1/2 -translate-x-1/2 bg-gray-800 p-3 rounded shadow-xl border border-gray-600 flex gap-3 hidden">
                <button onclick="applyCrop()" class="bg-blue-600 text-white px-4 py-1 rounded text-sm">ç¢ºèªè£åˆ‡</button>
                <button onclick="cancelCrop()" class="bg-gray-600 text-white px-4 py-1 rounded text-sm">å–æ¶ˆ</button>
            </div>
            
            <div id="loading-toast" class="absolute top-10 left-1/2 -translate-x-1/2 bg-blue-600 text-white px-6 py-2 rounded shadow-lg hidden">
                <i class="fas fa-spinner fa-spin mr-2"></i>è™•ç†ä¸­...
            </div>
        </div>

        <div class="w-64 bg-gray-800 border-l border-gray-700 flex flex-col shrink-0">
            <div class="p-3 border-b border-gray-700 font-bold bg-gray-900 text-center text-sm text-gray-300">å±¬æ€§é¢æ¿</div>
            <div class="p-4 flex-1 overflow-y-auto space-y-6">
                
                <div class="bg-gray-700/50 p-3 rounded">
                    <label class="text-xs text-gray-400 block mb-2">è¼¸å‡ºå°ºå¯¸ (px)</label>
                    <div class="flex items-center gap-2">
                        <input type="number" id="canvas-w" value="370" class="w-16 bg-gray-900 border border-gray-600 rounded px-1 text-center text-sm" onchange="resizeCanvasDimension()">
                        <span class="text-xs">x</span>
                        <input type="number" id="canvas-h" value="320" class="w-16 bg-gray-900 border border-gray-600 rounded px-1 text-center text-sm" onchange="resizeCanvasDimension()">
                    </div>
                    <button onclick="setStandardSize()" class="w-full mt-2 bg-gray-600 hover:bg-gray-500 text-xs py-1 rounded">é‡è¨­ç‚º Line æ¨™æº–</button>
                </div>

                <div id="panel-none" class="text-center text-gray-500 py-4 text-sm">
                    <p>æœªé¸å–ç‰©ä»¶</p>
                </div>

                <div id="panel-brush" class="hidden space-y-4">
                    <h3 class="text-sm font-bold text-blue-400 border-b border-gray-600 pb-1">ç­†åˆ·è¨­å®š</h3>
                    <div id="brush-color-wrap">
                        <label class="text-xs text-gray-400 block mb-1">é¡è‰²</label>
                        <input type="color" id="draw-color" value="#ffffff" class="w-full h-8 rounded cursor-pointer bg-transparent" onchange="updateBrush()">
                    </div>
                    <div>
                        <label class="text-xs text-gray-400 flex justify-between">ç²—ç´° <span id="brush-size-val">5</span></label>
                        <input type="range" id="draw-width" min="1" max="50" value="5" class="w-full" oninput="updateBrush()">
                    </div>
                </div>

                <div id="panel-object" class="hidden space-y-4">
                    <h3 class="text-sm font-bold text-green-400 border-b border-gray-600 pb-1">ç‰©ä»¶è¨­å®š</h3>
                    
                    <div class="flex gap-2">
                        <button onclick="toggleLock()" id="btn-lock" class="flex-1 bg-gray-700 py-1 rounded text-xs"><i class="fas fa-unlock mr-1"></i>é–å®š</button>
                        <button onclick="deleteActiveObject()" class="flex-1 bg-red-900/50 text-red-300 py-1 rounded text-xs"><i class="fas fa-trash mr-1"></i>åˆªé™¤</button>
                    </div>

                    <div>
                        <label class="text-xs text-gray-400 flex justify-between">æ—‹è½‰ <span id="rotation-val">0Â°</span></label>
                        <input type="range" id="angle-control" min="-180" max="180" value="0" class="w-full" oninput="setRotation(this.value)">
                        <div class="flex justify-between mt-1">
                            <button onclick="rotateObject(-90)" class="text-xs bg-gray-700 px-2 rounded">-90</button>
                            <button onclick="rotateObject(0)" class="text-xs bg-gray-700 px-2 rounded">0</button>
                            <button onclick="rotateObject(90)" class="text-xs bg-gray-700 px-2 rounded">+90</button>
                        </div>
                    </div>

                    <div>
                        <label class="text-xs text-gray-400 block mb-1">å¡«å……é¡è‰²</label>
                        <input type="color" id="obj-color" class="w-full h-8 rounded bg-transparent cursor-pointer" onchange="updateObject()">
                    </div>

                    <div id="text-controls" class="hidden space-y-3 border-t border-gray-600 pt-3">
                        <div>
                            <label class="text-xs text-gray-400 block mb-1">å­—å‹</label>
                            <select id="font-family" class="w-full bg-gray-900 border border-gray-600 rounded px-1 py-1 text-sm" onchange="handleFontChange()">
                                <option value="Noto Sans TC">æ€æºé»‘é«”</option>
                                <option value="Mochiy Pop One">å¯æ„›åœ“é«”</option>
                                <option value="Microsoft JhengHei">å¾®è»Ÿæ­£é»‘é«”</option>
                                <option value="Arial">Arial</option>
                                <option value="custom_input">â• è‡ªè¨‚...</option>
                            </select>
                            <div id="custom-font-area" class="hidden mt-1 flex gap-1">
                                <input type="text" id="custom-font-input" placeholder="å­—å‹åç¨±" class="w-full bg-gray-900 border border-gray-600 rounded px-1 text-xs">
                                <button onclick="saveCustomFont()" class="bg-blue-600 px-2 rounded text-xs">å­˜</button>
                            </div>
                        </div>
                        <div>
                            <label class="text-xs text-gray-400 flex justify-between">æé‚Šç²—ç´°</label>
                            <div class="flex items-center gap-2">
                                <input type="color" id="text-stroke-color" value="#ffffff" class="w-6 h-6 p-0 rounded-full border-none" onchange="updateObject()">
                                <input type="range" id="text-stroke-width" min="0" max="20" value="8" step="0.5" class="flex-1" oninput="updateObject()">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 1. åˆå§‹åŒ–
        fabric.Object.prototype.set({
            transparentCorners: false, cornerColor: '#3b82f6', cornerStyle: 'circle', borderColor: '#3b82f6', cornerSize: 10, padding: 5, borderScaleFactor: 2, rotatingPointOffset: 25
        });

        // åœ¨å‚³çµ±ç‰ˆé¢ä¸­ï¼ŒCanvas ä½”æ»¿ #canvas-area
        const canvas = new fabric.Canvas('c', {
            backgroundColor: null, // é€æ˜èƒŒæ™¯
            preserveObjectStacking: true,
            stopContextMenu: true,
            fireRightClick: true
        });

        let artboardW = 370, artboardH = 320;
        let guideFrame = null;
        let currentMode = 'select', cropRect = null;
        let isDragging = false, lastPosX, lastPosY;
        let undoStack = [], redoStack = [], isRedoing = false;
        let myFonts = JSON.parse(localStorage.getItem('sticker_my_fonts')) || [];
        let spacePressed = false;

        window.onload = function() {
            renderFontOptions();
            resizeCanvasToContainer();
            createGuideFrame();
            // ç›£è½è¦–çª—æ”¹è®Šï¼Œèª¿æ•´ Canvas å¤§å°
            window.addEventListener('resize', resizeCanvasToContainer);
        };

        function resizeCanvasToContainer() {
            const container = document.getElementById('canvas-area');
            canvas.setWidth(container.offsetWidth);
            canvas.setHeight(container.offsetHeight);
            if(guideFrame) centerArtboard();
        }

        function createGuideFrame() {
            if(guideFrame) canvas.remove(guideFrame);
            guideFrame = new fabric.Rect({
                id: 'guide-frame',
                width: artboardW, height: artboardH, 
                fill: 'transparent', 
                stroke: 'rgba(255, 255, 255, 0.5)', 
                strokeWidth: 1, strokeDashArray: [8, 4],
                selectable: false, evented: false, 
                originX: 'left', originY: 'top',
                hoverCursor: 'default'
            });
            canvas.add(guideFrame);
            guideFrame.bringToFront(); 
            centerArtboard();
        }

        // é‡è¦ï¼šå°‡ Artboard æ”¾åœ¨ç•«å¸ƒæ­£ä¸­å¤®
        function centerArtboard() {
            if(!guideFrame) return;
            // é‡ç½®è¦–åœ–
            canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
            
            // è¨ˆç®—ç½®ä¸­åç§»
            const x = (canvas.width - artboardW) / 2;
            const y = (canvas.height - artboardH) / 2;
            
            // ç§»å‹•æ‰€æœ‰ç‰©ä»¶ (é€™æ˜¯ä¸€ç¨®æ–¹å¼ï¼Œä½†æ›´å¥½çš„æ–¹å¼æ˜¯ç§»å‹• viewport)
            // é€™è£¡æˆ‘å€‘æ¡ç”¨ç§»å‹• Viewport çš„æ–¹å¼ï¼Œè®“ (0,0) å°æ‡‰åˆ° artboard çš„å·¦ä¸Šè§’æ¯”è¼ƒç›´è¦ºï¼Ÿ
            // ä¸ï¼ŒFabric ç¿’æ…£æ˜¯ç‰©ä»¶æœ‰çµ•å°åº§æ¨™ã€‚æˆ‘å€‘æŠŠ guideFrame æ”¾åˆ°ä¸­é–“ã€‚
            guideFrame.set({ left: x, top: y });
            guideFrame.setCoords();
            canvas.requestRenderAll();
            updateZoomDisplay();
        }

        function resizeCanvasDimension() {
            artboardW = parseInt(document.getElementById('canvas-w').value);
            artboardH = parseInt(document.getElementById('canvas-h').value);
            guideFrame.set({ width: artboardW, height: artboardH });
            centerArtboard();
        }
        function setStandardSize() {
            document.getElementById('canvas-w').value = 370; document.getElementById('canvas-h').value = 320;
            resizeCanvasDimension();
        }

        // --- æ ¸å¿ƒä¿®æ­£ï¼šè¼‰å…¥åœ–ç‰‡é‚è¼¯ ---
        function loadToCanvas(dataURL) {
            document.getElementById('loading-toast').classList.remove('hidden');
            const imgObj = new Image();
            imgObj.src = dataURL;
            imgObj.onload = function() {
                const imgInstance = new fabric.Image(imgObj);
                
                // 1. ç¸®æ”¾é‚è¼¯
                if (imgInstance.width > artboardW || imgInstance.height > artboardH) {
                    const scale = Math.min(artboardW / imgInstance.width, artboardH / imgInstance.height) * 0.9;
                    imgInstance.scale(scale);
                }
                
                // 2. ç¢ºä¿ guideFrame æœ‰åº§æ¨™
                const centerX = guideFrame.left + (artboardW / 2);
                const centerY = guideFrame.top + (artboardH / 2);

                // 3. æ”¾ç½®åœ¨ Artboard ä¸­å¿ƒ
                imgInstance.set({
                    left: centerX,
                    top: centerY,
                    originX: 'center',
                    originY: 'center'
                });

                canvas.add(imgInstance);
                // ç¢ºä¿è™›ç·šæ¡†åœ¨æœ€ä¸Šå±¤
                guideFrame.bringToFront();
                canvas.setActiveObject(imgInstance);
                canvas.requestRenderAll();
                saveState();
                document.getElementById('loading-toast').classList.add('hidden');
            };
        }

        // --- å°èˆª (å¹³ç§»/ç¸®æ”¾) ---
        canvas.on('mouse:down', function(opt) {
            const evt = opt.e;
            if (evt.button === 2 || evt.altKey || spacePressed || currentMode === 'pan') {
                this.isDragging = true; this.selection = false;
                this.lastPosX = evt.clientX; this.lastPosY = evt.clientY;
                canvas.defaultCursor = 'grabbing';
            }
        });
        canvas.on('mouse:move', function(opt) {
            if (this.isDragging) {
                var e = opt.e; var vpt = this.viewportTransform;
                vpt[4] += e.clientX - this.lastPosX; vpt[5] += e.clientY - this.lastPosY;
                this.requestRenderAll(); this.lastPosX = e.clientX; this.lastPosY = e.clientY;
                document.getElementById('floating-menu').style.display = 'none';
            }
        });
        canvas.on('mouse:up', function(opt) {
            if(this.isDragging) {
                this.setViewportTransform(this.viewportTransform); this.isDragging = false; this.selection = true;
                canvas.defaultCursor = currentMode === 'pan' ? 'grab' : 'default';
                if(canvas.getActiveObject()) updateFloatingMenu(canvas.getActiveObject());
            }
        });
        canvas.on('mouse:wheel', function(opt) {
            var delta = opt.e.deltaY; var zoom = canvas.getZoom(); zoom *= 0.999 ** delta;
            if (zoom > 10) zoom = 10; if (zoom < 0.1) zoom = 0.1;
            canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
            opt.e.preventDefault(); opt.e.stopPropagation(); updateZoomDisplay();
            if(canvas.getActiveObject()) updateFloatingMenu(canvas.getActiveObject());
        });

        // æ™ºæ…§å°ç„¦
        function zoomToFit() { centerArtboard(); }
        function resetViewport() { canvas.setViewportTransform([1,0,0,1,0,0]); centerArtboard(); }

        // --- å·¥å…·æ¨¡å¼ ---
        function setMode(mode) {
            if(currentMode === 'crop' && mode !== 'crop') cancelCrop();
            currentMode = mode;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            // ç°¡æ˜“æ˜ å°„
            const ids = { 'select': 'btn-select', 'draw': 'btn-draw', 'eraser': 'btn-eraser', 'crop': 'btn-crop', 'pan': 'btn-pan' };
            if(ids[mode]) document.getElementById(ids[mode]).classList.add('active');

            if (mode === 'draw' || mode === 'eraser') {
                canvas.isDrawingMode = true; canvas.discardActiveObject(); updateBrush();
            } else if (mode === 'pan') {
                canvas.isDrawingMode = false; canvas.defaultCursor = 'grab'; canvas.discardActiveObject();
            } else {
                canvas.isDrawingMode = false; canvas.defaultCursor = 'default';
            }
            canvas.requestRenderAll(); updatePanel();
        }

        // æ©¡çš®æ“¦ (Destination-out)
        function updateBrush() {
            if (!canvas.freeDrawingBrush) return;
            const size = parseInt(document.getElementById('draw-width').value);
            document.getElementById('brush-size-val').innerText = size;
            
            if (currentMode === 'eraser') {
                canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush.width = size;
                canvas.freeDrawingBrush.color = 'rgba(255,255,255,1)'; 
                document.getElementById('brush-color-wrap').classList.add('opacity-30', 'pointer-events-none');
            } else {
                canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush.width = size;
                canvas.freeDrawingBrush.color = document.getElementById('draw-color').value;
                document.getElementById('brush-color-wrap').classList.remove('opacity-30', 'pointer-events-none');
            }
        }
        canvas.on('path:created', function(opt) {
            if (currentMode === 'eraser') {
                const path = opt.path;
                path.globalCompositeOperation = 'destination-out'; 
                path.selectable = false; path.evented = false;
                if(guideFrame) guideFrame.bringToFront();
                canvas.requestRenderAll(); saveState();
            }
        });

        // è¼¸å‡º (è£åˆ‡ Artboard ç¯„åœ)
        function downloadImage() {
            canvas.discardActiveObject();
            document.getElementById('floating-menu').style.display = 'none';
            const originalVpt = canvas.viewportTransform.slice();
            canvas.viewportTransform = [1, 0, 0, 1, 0, 0]; // æš«æ™‚é‡ç½®è¦–åœ–ä»¥ç²¾ç¢ºè£åˆ‡
            
            if(guideFrame) guideFrame.visible = false;
            canvas.renderAll();

            setTimeout(() => {
                const link = document.createElement('a'); link.download = `sticker-${Date.now()}.png`;
                // æ“·å– guideFrame æ‰€åœ¨çš„å€åŸŸ
                link.href = canvas.toDataURL({ 
                    format: 'png', quality: 1, multiplier: 1, 
                    left: guideFrame.left, top: guideFrame.top, width: artboardW, height: artboardH 
                });
                link.click();
                
                if(guideFrame) guideFrame.visible = true;
                guideFrame.bringToFront();
                canvas.viewportTransform = originalVpt; // æ¢å¾©è¦–åœ–
                canvas.requestRenderAll();
            }, 50);
        }

        // äº‹ä»¶èˆ‡å…¶é¤˜è¼”åŠ©
        const imgLoader = document.getElementById('imgLoader');
        imgLoader.addEventListener('change', (e) => { const file = e.target.files[0]; if(!file) return; const reader = new FileReader(); reader.onload = (f) => loadToCanvas(f.target.result); reader.readAsDataURL(file); imgLoader.value = ''; });
        window.addEventListener('paste', (e) => { const items = (e.clipboardData || e.originalEvent.clipboardData).items; for (let item of items) { if (item.kind === 'file') { const reader = new FileReader(); reader.onload = (event) => loadToCanvas(event.target.result); reader.readAsDataURL(item.getAsFile()); }}});
        
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !spacePressed) { if(document.activeElement.tagName === 'INPUT') return; spacePressed = true; canvas.defaultCursor = 'grab'; }
            if (e.key === 'v') setMode('select'); if (e.key === 'b') setMode('draw'); if (e.key === 'e') setMode('eraser'); if (e.key === 'h') setMode('pan');
            if ((e.key === 'Delete' || e.key === 'Backspace')) deleteActiveObject();
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
            if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
        });
        window.addEventListener('keyup', (e) => { if (e.code === 'Space') { spacePressed = false; if(currentMode !== 'pan') canvas.defaultCursor = 'default'; } });

        // æµ®å‹•é¸å–®
        canvas.on('selection:created', (e) => { updatePanel(); updateFloatingMenu(e.selected[0]); });
        canvas.on('selection:updated', (e) => { updatePanel(); updateFloatingMenu(e.selected[0]); });
        canvas.on('selection:cleared', () => { updatePanel(); document.getElementById('floating-menu').style.display = 'none'; });
        canvas.on('object:moving', (e) => updateFloatingMenu(e.target));
        canvas.on('object:scaling', (e) => updateFloatingMenu(e.target));
        canvas.on('object:rotating', (e) => updateFloatingMenu(e.target));

        function updateFloatingMenu(obj) {
            if (!obj || obj.id === 'guide-frame') return;
            const menu = document.getElementById('floating-menu');
            const bound = obj.getBoundingRect();
            if (bound.top < -2000 || bound.left < -2000) { menu.style.display = 'none'; return; }
            menu.style.left = (bound.left + bound.width / 2) + 'px';
            menu.style.top = (bound.top - 10) + 'px';
            menu.style.display = 'flex';
            
            const isLocked = obj.lockMovementX;
            const lockBtn = document.getElementById('float-lock');
            lockBtn.style.color = isLocked ? '#ef4444' : '#d1d5db';
            
            document.getElementById('float-group').style.display = (obj.type === 'activeSelection') ? 'flex' : 'none';
            document.getElementById('float-ungroup').style.display = (obj.type === 'group') ? 'flex' : 'none';
        }

        function updatePanel() {
            const obj = canvas.getActiveObject();
            document.getElementById('panel-none').style.display = (!obj && !canvas.isDrawingMode) ? 'block' : 'none';
            document.getElementById('panel-brush').style.display = canvas.isDrawingMode ? 'block' : 'none';
            document.getElementById('panel-object').style.display = (obj && !canvas.isDrawingMode) ? 'block' : 'none';
            if(obj) {
                document.getElementById('rotation-val').innerText = parseInt(obj.angle % 360) + "Â°";
                document.getElementById('angle-control').value = parseInt(obj.angle % 360);
                if(typeof obj.fill === 'string') document.getElementById('obj-color').value = obj.fill;
                const isText = obj.type === 'i-text';
                document.getElementById('text-controls').classList.toggle('hidden', !isText);
                if(isText) {
                    document.getElementById('text-stroke-color').value = obj.stroke || '#ffffff';
                    document.getElementById('text-stroke-width').value = obj.strokeWidth || 0;
                }
            }
        }

        function deleteActiveObject() { const obj = canvas.getActiveObject(); if (obj && !obj.isEditing && obj.id !== 'guide-frame') { canvas.remove(obj); canvas.discardActiveObject(); updatePanel(); document.getElementById('floating-menu').style.display = 'none'; saveState(); } }
        function toggleLock() { const obj = canvas.getActiveObject(); if(!obj) return; const isLocked = !obj.lockMovementX; obj.set({ lockMovementX: isLocked, lockMovementY: isLocked, lockRotation: isLocked, lockScalingX: isLocked, lockScalingY: isLocked, borderColor: isLocked ? '#ef4444' : '#3b82f6', hasControls: !isLocked }); canvas.requestRenderAll(); updateFloatingMenu(obj); updatePanel(); saveState(); }
        function groupObjects() { if (!canvas.getActiveObject()) return; if (canvas.getActiveObject().type !== 'activeSelection') return; canvas.getActiveObject().toGroup(); canvas.requestRenderAll(); updatePanel(); saveState(); }
        function ungroupObjects() { if (!canvas.getActiveObject()) return; if (canvas.getActiveObject().type !== 'group') return; canvas.getActiveObject().toActiveSelection(); canvas.requestRenderAll(); updatePanel(); saveState(); }
        function bringToFront() { const obj = canvas.getActiveObject(); if(obj) { obj.bringToFront(); if(guideFrame) guideFrame.bringToFront(); saveState(); } }
        function sendToBack() { const obj = canvas.getActiveObject(); if(obj) { obj.sendToBack(); saveState(); } }
        function saveState() { if (isRedoing) return; redoStack = []; if(undoStack.length > 20) undoStack.shift(); undoStack.push(canvas.toJSON()); document.getElementById('btn-undo').disabled = undoStack.length === 0; document.getElementById('btn-redo').disabled = redoStack.length === 0; }
        function undo() { if (undoStack.length > 0) { isRedoing = true; redoStack.push(canvas.toJSON()); const state = undoStack.pop(); canvas.loadFromJSON(state, () => { canvas.renderAll(); isRedoing = false; updatePanel(); }); } document.getElementById('btn-undo').disabled = undoStack.length === 0; document.getElementById('btn-redo').disabled = redoStack.length === 0; }
        function redo() { if (redoStack.length > 0) { isRedoing = true; undoStack.push(canvas.toJSON()); const state = redoStack.pop(); canvas.loadFromJSON(state, () => { canvas.renderAll(); isRedoing = false; updatePanel(); }); } document.getElementById('btn-undo').disabled = undoStack.length === 0; document.getElementById('btn-redo').disabled = redoStack.length === 0; }
        function updateZoomDisplay() { document.getElementById('zoom-val').innerText = Math.round(canvas.getZoom() * 100) + '%'; }
        
        function addText() { setMode('select'); const text = new fabric.IText('Text', { left: guideFrame.left + artboardW/2, top: guideFrame.top + artboardH/2, originX: 'center', originY: 'center', fontFamily: 'Noto Sans TC', fontSize: 60, fill: '#ffffff', stroke: '#000000', strokeWidth: 8, paintFirst: 'stroke', fontWeight: '900' }); canvas.add(text); canvas.setActiveObject(text); if(guideFrame) guideFrame.bringToFront(); }
        function updateObject() { const obj = canvas.getActiveObject(); if (!obj) return; obj.set('fill', document.getElementById('obj-color').value); if (obj.type === 'i-text') { let fontVal = document.getElementById('font-family').value; if (fontVal === 'custom_input') fontVal = document.getElementById('custom-font-input').value || 'sans-serif'; obj.set({ fontFamily: fontVal, stroke: document.getElementById('text-stroke-color').value, strokeWidth: parseFloat(document.getElementById('text-stroke-width').value) }); } canvas.requestRenderAll(); }
        function setRotation(angle) { const obj = canvas.getActiveObject(); if(!obj) return; obj.set('angle', parseInt(angle)); document.getElementById('rotation-val').innerText = parseInt(angle) + "Â°"; canvas.requestRenderAll(); }
        document.getElementById('angle-control').addEventListener('change', saveState);
        function rotateObject(deg) { const obj = canvas.getActiveObject(); if(!obj) return; let currentAngle = obj.angle; obj.rotate(currentAngle + deg); canvas.requestRenderAll(); updatePanel(); saveState(); }
        function renderFontOptions() { const group = document.getElementById('saved-fonts-group'); group.innerHTML = ''; if (myFonts.length === 0) { const opt = document.createElement('option'); opt.text = "(None)"; opt.disabled = true; group.appendChild(opt); } else { myFonts.forEach(fontName => { const opt = document.createElement('option'); opt.value = fontName; opt.text = fontName; group.appendChild(opt); }); } }
        function handleFontChange() { const select = document.getElementById('font-family'); const customArea = document.getElementById('custom-font-area'); if (select.value === 'custom_input') { customArea.classList.remove('hidden'); document.getElementById('custom-font-input').focus(); } else { customArea.classList.add('hidden'); updateObject(); } }
        function saveCustomFont() { const name = document.getElementById('custom-font-input').value.trim(); if (!name) return; if (!myFonts.includes(name)) { myFonts.unshift(name); localStorage.setItem('sticker_my_fonts', JSON.stringify(myFonts)); renderFontOptions(); document.getElementById('font-family').value = name; document.getElementById('custom-font-area').classList.add('hidden'); updateObject(); alert(`Saved: ${name}`); } else { document.getElementById('font-family').value = name; updateObject(); } }
        function duplicateObject() { const obj = canvas.getActiveObject(); if(!obj || obj.id === 'guide-frame') return; obj.clone(function(cloned) { canvas.discardActiveObject(); cloned.set({ left: cloned.left + 20, top: cloned.top + 20, evented: true }); if (cloned.type === 'activeSelection') { cloned.canvas = canvas; cloned.forEachObject(function(o) { canvas.add(o); }); cloned.setCoords(); } else { canvas.add(cloned); } canvas.setActiveObject(cloned); if(guideFrame) guideFrame.bringToFront(); canvas.requestRenderAll(); saveState(); }); }
        function startCrop() { setMode('crop'); document.getElementById('crop-controls').classList.remove('hidden'); cropRect = new fabric.Rect({ fill: 'rgba(0,0,0,0.5)', stroke: '#38bdf8', strokeWidth: 2, strokeDashArray: [10, 5], left: guideFrame.left, top: guideFrame.top, width: artboardW, height: artboardH, selectable: true, hasRotatingPoint: false, lockRotation: true, cornerColor: 'white', cornerStrokeColor: '#38bdf8', transparentCorners: false }); canvas.add(cropRect); canvas.setActiveObject(cropRect); if(guideFrame) guideFrame.bringToFront(); }
        function cancelCrop() { if (cropRect) canvas.remove(cropRect); document.getElementById('crop-controls').classList.add('hidden'); setMode('select'); }
        function applyCrop() { if (!cropRect) return; const { left, top, width, height } = cropRect.getBoundingRect(); cropRect.visible = false; const url = canvas.toDataURL({ left, top, width, height, format: 'png', multiplier: 1 }); canvas.clear(); createGuideFrame(); loadToCanvas(url); cancelCrop(); }

    </script>
</body>
</html>
