<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sticker Studio Air - Pro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&family=Zen+Maru+Gothic:wght@400;700;900&family=Biz+UDGothic&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>

    <style>
        :root {
            --bg-color: #e5e5e5;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --accent-color: #007AFF;
            --danger-color: #FF3B30;
            --text-color: #333;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: "Noto Sans TC", sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(#ccc 1px, transparent 1px);
            background-size: 20px 20px;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        /* 介面容器 */
        .ui-panel {
            position: absolute;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
            border-radius: 12px;
            padding: 6px;
            z-index: 100;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        /* 1. 主工具列 (Top) */
        .toolbar-main { top: 20px; height: 44px; }
        
        /* 2. 屬性工具列 (Sub Top) - 動態顯示 */
        .toolbar-props { 
            top: 80px; 
            padding: 8px 16px;
            min-width: 200px;
            justify-content: center;
            display: none; /* 預設隱藏 */
            animation: slideDown 0.2s ease-out;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* 3. 左側工具列 */
        .toolbar-left { 
            left: 20px; 
            flex-direction: column; 
            top: 50%; 
            transform: translateY(-50%); 
        }

        /* UI 元件樣式 */
        button {
            background: transparent;
            border: none;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #555;
            min-width: 48px;
        }
        button:hover { background: rgba(0,0,0,0.05); color: var(--accent-color); }
        button.active { background: #e0eaff; color: var(--accent-color); }
        
        button svg { width: 20px; height: 20px; margin-bottom: 2px;}
        button span { font-size: 10px; font-weight: 500;}

        /* 分隔線 */
        .divider { width:1px; height:24px; background:#ddd; margin: 0 4px; }

        /* 選單與滑塊 */
        select {
            padding: 6px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-size: 13px;
            background: transparent;
            color: #333;
            outline: none;
        }
        
        .slider-group {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #555;
        }
        input[type=range] {
            width: 100px;
            accent-color: var(--accent-color);
        }

        /* 畫布 */
        #viewport {
            width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            outline: none;
        }
        .canvas-wrapper {
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            border: 1px solid rgba(0,0,0,0.05);
            background-color: #849ebf; /* LINE 預設背景 */
            transition: background-color 0.3s;
        }

        /* 狀態列 */
        .status-bar {
            position: absolute; bottom: 20px; right: 20px;
            font-size: 12px; color: #666; background: var(--panel-bg);
            padding: 8px 16px; border-radius: 20px; pointer-events: none;
        }
    </style>
</head>
<body>

    <input type="file" id="fileInput" accept="image/*" style="display:none">

    <div class="ui-panel toolbar-main">
        <span style="font-weight:900; font-size:16px; margin: 0 10px; color:#333;">Sticker Pro</span>
        <div class="divider"></div>
        
        <button onclick="triggerUpload()" title="上傳">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>
            <span>匯入</span>
        </button>
        <button onclick="addText()" title="文字">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7V4h16v3M9 20h6M12 4v16"/></svg>
            <span>文字</span>
        </button>
        
        <div class="divider"></div>

        <button onclick="toggleEraser()" id="btnEraser" title="橡皮擦 (白色遮罩)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16C2 15 2 13 3 12L13 2L22 11L20 20Z"/><line x1="11" y1="11" x2="14" y2="14"/></svg>
            <span>橡皮擦</span>
        </button>

        <button onclick="removeWhite()" title="去除白色 (魔術棒)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 4V2m0 2v2m0-2h2m-2 0h-2M4 15l3 3 9-9-3-3-9 9z"/></svg>
            <span>去背</span>
        </button>

        <div class="divider"></div>

        <button onclick="undo()" title="復原 (Ctrl+Z)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>
            <span>復原</span>
        </button>

        <button onclick="downloadPNG()" style="color: var(--accent-color);">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>
            <span>匯出</span>
        </button>
    </div>

    <div class="ui-panel toolbar-props" id="propPanel">
        <div id="textProps" style="display:none; align-items:center; gap:10px;">
            <select id="fontFamilySelect" onchange="changeFont(this.value)">
                <option value="'Noto Sans TC'">思源黑體</option>
                <option value="'Zen Maru Gothic'">可愛圓體</option>
                <option value="'Biz UDGothic'">日系黑體</option>
                <option value="Arial">Arial</option>
            </select>
            <div class="divider"></div>
        </div>

        <div class="slider-group">
            <span>白邊</span>
            <input type="range" id="strokeRange" min="0" max="15" value="0" step="1" oninput="updateStroke(this.value)">
            <span id="strokeValue">0</span>
        </div>
    </div>

    <div class="ui-panel toolbar-left">
        <button onclick="toggleBackground()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
        </button>
        
        <button onclick="deleteObject()" style="color: var(--danger-color);">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
        </button>
    </div>

    <div id="viewport">
        <div class="canvas-wrapper">
            <canvas id="c" width="370" height="320"></canvas>
        </div>
    </div>

    <div class="status-bar">空白鍵拖曳 • 滾輪縮放 • Ctrl+Z 復原</div>

    <script>
        // === 1. 初始化 Fabric Canvas ===
        const canvas = new fabric.Canvas('c', {
            preserveObjectStacking: true,
            isDrawingMode: false
        });

        // 畫筆預設為白色 (橡皮擦效果)
        canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
        canvas.freeDrawingBrush.color = "white";
        canvas.freeDrawingBrush.width = 20;

        // 樣式設定
        fabric.Object.prototype.set({
            transparentCorners: false,
            cornerColor: '#fff',
            cornerStrokeColor: '#007AFF',
            borderColor: '#007AFF',
            cornerSize: 10,
            cornerStyle: 'circle'
        });

        // === 2. 歷史紀錄系統 (Undo) ===
        let historyStack = [];
        let historyProcessing = false;

        function saveHistory() {
            if(historyProcessing) return;
            if(historyStack.length > 10) historyStack.shift(); // 限制步數
            historyStack.push(JSON.stringify(canvas));
        }

        // 監聽變更事件自動存檔
        canvas.on('object:added', saveHistory);
        canvas.on('object:modified', saveHistory);
        canvas.on('object:removed', saveHistory);
        // 初始化存第一步
        saveHistory();

        function undo() {
            if (historyStack.length <= 1) return; // 至少保留最後狀態
            
            historyProcessing = true;
            historyStack.pop(); // 移除當前狀態
            const prevState = historyStack[historyStack.length - 1];
            
            canvas.loadFromJSON(prevState, function() {
                canvas.renderAll();
                historyProcessing = false;
            });
        }

        // 監聽鍵盤 Ctrl+Z
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if(!canvas.getActiveObject()?.isEditing) deleteObject();
            }
        });

        // === 3. 橡皮擦功能 ===
        let isEraserMode = false;
        function toggleEraser() {
            isEraserMode = !isEraserMode;
            canvas.isDrawingMode = isEraserMode;
            
            const btn = document.getElementById('btnEraser');
            if(isEraserMode) {
                btn.classList.add('active');
                canvas.defaultCursor = 'crosshair';
            } else {
                btn.classList.remove('active');
                canvas.defaultCursor = 'default';
            }
        }

        // 去除白色 (Magic Wand)
        function removeWhite() {
            const activeObj = canvas.getActiveObject();
            // 如果沒選東西，就嘗試把整個畫布去背 (包含橡皮擦塗過的痕跡)
            // 這裡為了簡單，我們針對選取的圖片做去背
            if (activeObj && activeObj.type === 'image') {
                const filter = new fabric.Image.filters.RemoveColor({
                    threshold: 0.15,
                    distance: 0.5
                });
                activeObj.filters.push(filter);
                activeObj.applyFilters();
                canvas.requestRenderAll();
                saveHistory();
            } else {
                alert('請先選取一張圖片來執行去背');
            }
        }

        // === 4. UI 互動與屬性控制 ===
        const propPanel = document.getElementById('propPanel');
        const textProps = document.getElementById('textProps');
        const strokeRange = document.getElementById('strokeRange');
        const strokeValue = document.getElementById('strokeValue');

        // 當選取物件改變時
        canvas.on('selection:created', updatePropsUI);
        canvas.on('selection:updated', updatePropsUI);
        canvas.on('selection:cleared', () => {
            propPanel.style.display = 'none';
        });

        function updatePropsUI() {
            const obj = canvas.getActiveObject();
            if(!obj) return;

            propPanel.style.display = 'flex';
            
            // 判斷是否為文字
            if(obj.type === 'i-text') {
                textProps.style.display = 'flex';
                // 同步 UI 數值
                document.getElementById('fontFamilySelect').value = obj.fontFamily;
                strokeRange.value = obj.strokeWidth || 0;
                strokeValue.textContent = obj.strokeWidth || 0;
            } else {
                textProps.style.display = 'none';
                // 圖片白邊判定
                if(obj.shadow) {
                    // 粗略用 offset 來回推數值
                    strokeRange.value = obj.shadow.offsetX; 
                    strokeValue.textContent = obj.shadow.offsetX;
                } else {
                    strokeRange.value = 0;
                    strokeValue.textContent = 0;
                }
            }
        }

        // 更改字型
        function changeFont(font) {
            const obj = canvas.getActiveObject();
            if(obj && obj.type === 'i-text') {
                obj.set("fontFamily", font);
                canvas.requestRenderAll();
                saveHistory();
            }
        }

        // 調整白邊 (核心邏輯)
        function updateStroke(val) {
            const width = parseInt(val);
            strokeValue.textContent = width;
            const obj = canvas.getActiveObject();
            if(!obj) return;

            if (width === 0) {
                obj.set({ strokeWidth: 0, stroke: null, shadow: null });
            } else {
                if (obj.type === 'i-text') {
                    // 文字用原生的 stroke
                    obj.set({
                        stroke: '#fff',
                        strokeWidth: width,
                        paintFirst: 'stroke' // 讓描邊在字體後方
                    });
                } else {
                    // 圖片：使用 "硬陰影" 模擬白邊 (blur: 0, opacity: 1)
                    // 這比投影更像框線
                    obj.set({
                        shadow: new fabric.Shadow({
                            color: '#ffffff',
                            blur: 0,    // 關鍵：無模糊，呈現實心
                            offsetX: width/2, // 稍微偏移製造厚度
                            offsetY: width/2,
                            opacity: 1
                        })
                    });
                    
                    // 備註：完美的圖片輪廓描邊在 Canvas 需要複雜運算 (Edge Detection)
                    // 這裡使用硬陰影是網頁效能最好的模擬方案
                }
            }
            canvas.requestRenderAll();
        }

        // === 5. 基礎功能 (上傳、下載、視窗控制) ===
        // (保持原有的視窗控制邏輯)
        
        function triggerUpload() { document.getElementById('fileInput').click(); }
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(f) {
                fabric.Image.fromURL(f.target.result, function(img) {
                    if (img.width > 250) img.scaleToWidth(250);
                    canvas.add(img);
                    canvas.centerObject(img);
                    canvas.setActiveObject(img);
                    saveHistory(); // 存檔
                });
            };
            reader.readAsDataURL(file);
            this.value = '';
        });

        function addText() {
            const text = new fabric.IText('輸入文字', {
                left: 100, top: 100,
                fontFamily: 'Noto Sans TC',
                fill: '#333', fontSize: 40, fontWeight: '900'
            });
            canvas.add(text);
            canvas.setActiveObject(text);
            saveHistory();
        }

        function deleteObject() {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length) {
                canvas.discardActiveObject();
                activeObjects.forEach((obj) => canvas.remove(obj));
                saveHistory();
            }
        }

        // 背景切換
        const wrapper = document.querySelector('.canvas-wrapper');
        const bgColors = ['#849ebf', '#ffffff', '#1a1a1a', 'transparent'];
        let bgIndex = 0;
        function toggleBackground() {
            bgIndex = (bgIndex + 1) % bgColors.length;
            const color = bgColors[bgIndex];
            wrapper.style.backgroundColor = color;
            if(color === 'transparent') {
                wrapper.style.backgroundImage = 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%)';
                wrapper.style.backgroundSize = '20px 20px';
                wrapper.style.backgroundPosition = '0 0, 0 10px, 10px -10px, -10px 0px';
            } else {
                wrapper.style.backgroundImage = 'none';
            }
        }

        function downloadPNG() {
            canvas.discardActiveObject();
            canvas.requestRenderAll();
            setTimeout(() => {
                const dataURL = canvas.toDataURL({ format: 'png', quality: 1, multiplier: 1 });
                const link = document.createElement('a');
                link.download = `sticker-${Date.now()}.png`;
                link.href = dataURL;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }, 50);
        }

        // 視窗平移與縮放邏輯 (沿用)
        const viewport = document.getElementById('viewport');
        let isSpaceDown = false;
        let isDragging = false;
        let lastPosX, lastPosY;
        let panX = 0, panY = 0, currentScale = 1;

        viewport.addEventListener('wheel', (opt) => {
            opt.preventDefault();
            const delta = opt.deltaY * -0.001;
            currentScale = Math.min(Math.max(0.5, currentScale + delta), 4);
            wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${currentScale})`;
        }, { passive: false });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                isSpaceDown = true;
                viewport.style.cursor = 'grab';
                canvas.selection = false;
            }
        });
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                isSpaceDown = false;
                viewport.style.cursor = 'default';
                canvas.selection = true;
            }
        });
        viewport.addEventListener('mousedown', (e) => {
            if (isSpaceDown) {
                isDragging = true;
                viewport.style.cursor = 'grabbing';
                lastPosX = e.clientX;
                lastPosY = e.clientY;
            }
        });
        viewport.addEventListener('mousemove', (e) => {
            if (isDragging) {
                panX += (e.clientX - lastPosX);
                panY += (e.clientY - lastPosY);
                lastPosX = e.clientX;
                lastPosY = e.clientY;
                wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${currentScale})`;
            }
        });
        viewport.addEventListener('mouseup', () => isDragging = false);

    </script>
</body>
</html>
