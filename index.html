<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LINE è²¼åœ–è£½ä½œå¤§å¸« (V26: çµ‚æ¥µæ——è‰¦ç‰ˆ)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

    <style>
        /* --- V26 æ ¸å¿ƒé…è‰² --- */
        :root {
            --primary: #06C755; --primary-hover: #05a546; --accent: #3b82f6;
            --bg: #121212; --card-bg: #1e1e1e; --panel-bg: #2a2a2a;
            --text-main: #e0e0e0; --text-sub: #a0a0a0; --border: #444;
            --input-bg: #333;
        }
        body.light-mode {
            --bg: #f3f4f6; --card-bg: #ffffff; --panel-bg: #f9fafb;
            --text-main: #1f2937; --text-sub: #6b7280; --border: #e5e7eb;
            --input-bg: #fff;
        }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text-main); margin: 0; padding: 20px; transition: 0.3s; padding-bottom: 80px; }
        
        /* ä½ˆå±€ç³»çµ± */
        .container { max-width: 1400px; margin: 0 auto; display: grid; grid-template-columns: 380px 1fr; gap: 20px; align-items: start; }
        .card { background: var(--card-bg); padding: 15px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 12px; border: 1px solid var(--border); }
        .sticky-sidebar { position: sticky; top: 10px; height: calc(100vh - 40px); overflow-y: auto; }
        
        /* æ¨™é¡Œèˆ‡æŒ‰éˆ• */
        .header { display: flex; justify-content: space-between; align-items: center; max-width: 1400px; margin: 0 auto 15px auto; }
        h1 { margin: 0; font-size: 1.5rem; font-weight: 800; background: linear-gradient(45deg, #06C755, #2ecc71); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        .btn { padding: 8px 12px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: 0.2s; display: flex; align-items: center; justify-content: center; gap: 5px; font-size: 0.9rem; }
        .btn-green { background: var(--primary); color: white; } .btn-green:hover { background: var(--primary-hover); }
        .btn-blue { background: var(--accent); color: white; } .btn-blue:hover { background: #2563eb; }
        .btn-sec { background: var(--input-bg); border: 1px solid var(--border); color: var(--text-main); } .btn-sec:hover { background: var(--panel-bg); }
        
        /* è¼¸å…¥å…ƒä»¶ */
        .row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .label { width: 70px; font-size: 0.85rem; color: var(--text-sub); flex-shrink: 0; }
        input[type="range"] { flex: 1; accent-color: var(--primary); height: 4px; border-radius: 2px; }
        input[type="number"], input[type="text"], select { background: var(--input-bg); border: 1px solid var(--border); color: var(--text-main); padding: 5px; border-radius: 4px; width: 60px; text-align: center; }
        input[type="color"] { width: 30px; height: 30px; border: none; padding: 0; background: none; cursor: pointer; }

        /* åƒè€ƒåœ–å€åŸŸ (Accordion) */
        .ref-box { border: 1px solid var(--border); background: var(--panel-bg); border-radius: 8px; overflow: hidden; transition: 0.3s; }
        .ref-header { padding: 10px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; background: rgba(0,0,0,0.05); }
        .ref-body { padding: 10px; display: none; }
        .ref-box.active .ref-body { display: block; }
        #refCanvas { width: 100%; max-height: 250px; object-fit: contain; background-image: conic-gradient(#333 25%, transparent 25%), conic-gradient(transparent 75%, #333 75%); background-size: 20px 20px; background-color: #222; }

        /* é è¦½ç¶²æ ¼ */
        #previewGrid { display: grid; gap: 15px; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); padding: 10px; min-height: 300px; }
        .sticker-item { 
            background: var(--input-bg); border: 1px solid var(--border); border-radius: 8px; overflow: hidden; position: relative; 
            transition: transform 0.2s; cursor: grab; display: flex; flex-direction: column;
        }
        .sticker-item:active { cursor: grabbing; transform: scale(1.02); z-index: 10; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .img-wrap { 
            width: 100%; aspect-ratio: 1; display: flex; align-items: center; justify-content: center; position: relative;
            background-image: conic-gradient(#444 25%, transparent 25%), conic-gradient(transparent 75%, #444 75%); background-size: 16px 16px; background-color: #333;
        }
        .img-wrap.bg-line { background: #849ebf; background-image: none; }
        .img-wrap img { max-width: 100%; max-height: 100%; object-fit: contain; pointer-events: none; }
        
        /* è²¼åœ–ä¸Šçš„æŒ‰éˆ• */
        .item-actions { position: absolute; top: 5px; right: 5px; display: flex; gap: 5px; }
        .action-btn { width: 24px; height: 24px; border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; color: white; opacity: 0.8; transition: 0.2s; }
        .action-btn:hover { opacity: 1; transform: scale(1.1); }
        .btn-edit { background: #3b82f6; } .btn-dl { background: #06C755; }
        .edited-badge { position: absolute; top: 5px; left: 5px; background: #eab308; color: black; font-size: 10px; padding: 2px 6px; border-radius: 10px; font-weight: bold; display: none; }
        .sticker-item.edited .edited-badge { display: block; }

        /* Modal ç·¨è¼¯å™¨ */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); }
        .editor-win { 
            background: var(--card-bg); width: 90%; max-width: 1000px; height: 90vh; margin: 2vh auto; 
            border-radius: 12px; display: grid; grid-template-rows: 50px 1fr 60px; overflow: hidden; border: 1px solid var(--border);
        }
        .editor-head { display: flex; justify-content: space-between; align-items: center; padding: 0 20px; border-bottom: 1px solid var(--border); }
        .editor-body { display: grid; grid-template-columns: 280px 1fr; overflow: hidden; }
        .editor-tools { padding: 15px; border-right: 1px solid var(--border); overflow-y: auto; background: var(--panel-bg); }
        .editor-canvas-area { display: flex; align-items: center; justify-content: center; background: #121212; position: relative; overflow: hidden; }
        .editor-foot { padding: 0 20px; border-top: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: var(--panel-bg); }

        /* å·¥å…·æ¨£å¼ */
        .tool-group { margin-bottom: 20px; border: 1px solid var(--border); border-radius: 8px; padding: 10px; background: var(--card-bg); }
        .tool-title { font-size: 0.85rem; font-weight: bold; color: var(--text-sub); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
        .mode-btn { width: 100%; text-align: left; padding: 8px; margin-bottom: 5px; border-radius: 6px; background: transparent; border: 1px solid transparent; color: var(--text-main); cursor: pointer; display: flex; align-items: center; gap: 8px; }
        .mode-btn.active { background: rgba(6, 199, 85, 0.15); border-color: var(--primary); color: var(--primary); font-weight: bold; }
        .mode-btn:hover:not(.active) { background: var(--input-bg); }

        /* Canvas */
        #editCanvas { box-shadow: 0 0 20px rgba(0,0,0,0.5); background-image: conic-gradient(#333 25%, transparent 25%), conic-gradient(transparent 75%, #333 75%); background-size: 20px 20px; }
        .cursor-pen { cursor: crosshair; }
    </style>
</head>
<body>

<div class="header">
    <h1>LINE è²¼åœ–è£½ä½œå¤§å¸« <span style="font-size:0.5em; color:var(--text-sub); border:1px solid var(--border); padding:2px 6px; border-radius:4px;">V26 æ——è‰¦ç‰ˆ</span></h1>
    <div style="display:flex; gap:10px;">
        <button class="btn btn-sec" onclick="toggleTheme()">ğŸŒ— åˆ‡æ›æ¨¡å¼</button>
    </div>
</div>

<div class="container">
    <div class="card sticky-sidebar">
        <div class="section-box">
            <div style="font-weight:bold; margin-bottom:10px;">ğŸ“· 1. åœ–ç‰‡ä¾†æº</div>
            <label class="btn btn-blue" style="width:100%; height:80px; display:flex; flex-direction:column;">
                <span style="font-size:1.5rem;">ğŸ“‚</span>
                <span>é»æ“Šä¸Šå‚³æˆ–æ‹–æ”¾åœ–ç‰‡</span>
                <input type="file" id="imgInput" style="display:none" accept="image/*">
            </label>
        </div>

        <div class="section-box">
            <div style="font-weight:bold; margin-bottom:10px;">âœ‚ï¸ 2. è£åˆ‡è¨­å®š</div>
            <div class="row">
                <span class="label">å‚ç›´ (åˆ—)</span>
                <input type="number" id="rows" value="4" min="1">
                <span class="label" style="text-align:right;">æ°´å¹³ (è¡Œ)</span>
                <input type="number" id="cols" value="5" min="1">
            </div>
            <div class="row">
                <span class="label">è‡ªå‹•ç½®ä¸­</span>
                <input type="checkbox" id="autoCenter" checked style="width:20px;">
                <span style="font-size:0.8rem; color:var(--text-sub);">è£åˆ‡å¾Œè‡ªå‹•æœ€å¤§åŒ–</span>
            </div>
        </div>

        <div class="section-box">
            <div style="font-weight:bold; margin-bottom:10px;">ğŸ¨ 3. æ‰¹æ¬¡å»èƒŒèˆ‡ç‰¹æ•ˆ</div>
            <div class="row">
                <span class="label">å»èƒŒé¡è‰²</span>
                <input type="color" id="targetColor" value="#FFFFFF">
                <button class="btn btn-sec" style="padding:2px 8px; font-size:0.8rem;" onclick="setColor('#FFFFFF')">ç™½</button>
                <button class="btn btn-sec" style="padding:2px 8px; font-size:0.8rem;" onclick="setColor('#00FF00')">ç¶ </button>
            </div>
            <div class="row"><span class="label">å¯¬å®¹åº¦</span><input type="range" id="tolerance" min="0" max="100" value="40"><span id="v_tolerance">40%</span></div>
            <div class="row"><span class="label">æŸ”åŒ–</span><input type="range" id="smoothness" min="0" max="10" step="0.5" value="0"><span id="v_smoothness">0</span></div>
            <div class="row"><span class="label">å…§ç¸®</span><input type="range" id="shrink" min="0" max="20" step="0.5" value="0"><span id="v_shrink">0</span></div>
            <div class="row"><span class="label">æ·¨åŒ–</span><input type="range" id="defringe" min="0" max="20" step="1" value="0"><span id="v_defringe">0</span></div>
            <hr style="border-color:var(--border); opacity:0.3;">
            <div class="row"><span class="label">æé‚Š</span><input type="range" id="contour" min="0" max="20" value="5"><input type="color" id="contourColor" value="#FFFFFF"></div>
            <div class="row"><span class="label">é™°å½±</span><input type="range" id="shadowOpacity" min="0" max="100" value="30"><input type="color" id="shadowColor" value="#000000"></div>
        </div>

        <button id="runBtn" class="btn btn-green" style="height:50px; font-size:1.1rem;">ğŸš€ é–‹å§‹è£½ä½œå…¨å¥—è²¼åœ–</button>
    </div>

    <div class="card">
        <div class="ref-box" id="refBox">
            <div class="ref-header" onclick="toggleRefBox()">
                <b>ğŸ“Œ åŸå§‹åœ–åƒè€ƒ & ä½ç½®å¾®èª¿</b> <span>â–¼</span>
            </div>
            <div class="ref-body">
                <div style="margin-bottom:10px; display:flex; gap:10px; justify-content:center;">
                    <button class="btn btn-sec" onclick="moveImg(0, 0.05)">â•</button>
                    <button class="btn btn-sec" onclick="moveImg(0, -0.05)">â–</button>
                    <button class="btn btn-sec" onclick="moveImg('y', 0.05)">â¬†ï¸</button>
                    <button class="btn btn-sec" onclick="moveImg('y', -0.05)">â¬‡ï¸</button>
                    <button class="btn btn-sec" onclick="moveImg('x', 0.05)">â¬…ï¸</button>
                    <button class="btn btn-sec" onclick="moveImg('x', -0.05)">â¡ï¸</button>
                    <button class="btn btn-sec" onclick="resetMove()">é‡ç½®</button>
                </div>
                <div style="position:relative; text-align:center;">
                    <canvas id="refCanvas"></canvas>
                    <div style="position:absolute; bottom:5px; right:5px; background:rgba(0,0,0,0.6); color:white; padding:2px 6px; font-size:0.7rem; border-radius:4px;">é»æ“Šå¸è‰²</div>
                </div>
            </div>
        </div>

        <div style="display:flex; justify-content:space-between; flex-wrap:wrap; gap:10px;">
            <div class="row" style="margin:0;">
                <span class="label" style="width:auto;">èµ·å§‹æª”å:</span>
                <input type="text" id="startNum" value="001" style="width:80px;">
            </div>
            <div style="display:flex; gap:5px;">
                <button class="btn btn-sec" onclick="setBg('dark')">â¬›</button>
                <button class="btn btn-sec" onclick="setBg('line')" style="background:#849ebf;">LINE</button>
                <button class="btn btn-sec" onclick="setBg('light')">â¬œ</button>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <label style="font-size:0.85rem; cursor:pointer; display:flex; align-items:center;">
                    <input type="checkbox" id="compressPng"> PNGå£“ç¸®
                </label>
                <button class="btn btn-green" onclick="downloadAll()">ğŸ“¦ ä¸‹è¼‰ ZIP</button>
            </div>
        </div>

        <div id="previewGrid">
            <div style="grid-column:1/-1; text-align:center; padding:50px; color:var(--text-sub);">
                è«‹å…ˆä¸Šå‚³åœ–ç‰‡ä¸¦é»æ“Šã€Œé–‹å§‹è£½ä½œã€
            </div>
        </div>
    </div>
</div>

<div id="editorModal" class="modal">
    <div class="editor-win">
        <div class="editor-head">
            <h3>ğŸ› ï¸ ç²¾ä¿®ç·¨è¼¯å™¨ - <span id="editorTitle"></span></h3>
            <div style="display:flex; gap:10px;">
                <button class="btn btn-sec" onclick="editorUndo()">â†©ï¸ å¾©åŸ</button>
                <button class="btn btn-sec" onclick="editorRedo()">â†ªï¸ é‡åš</button>
                <button class="btn btn-green" onclick="saveEditor()">âœ… å®Œæˆ</button>
                <button class="btn btn-sec" onclick="closeEditor()" style="color:#ff5252;">é—œé–‰</button>
            </div>
        </div>
        <div class="editor-body">
            <div class="editor-tools">
                <div class="tool-group">
                    <div class="tool-title">ä¿®åœ–å·¥å…·</div>
                    <button class="mode-btn active" id="tool-move" onclick="setTool('move')">âœ‹ ç§»å‹•/æª¢è¦–</button>
                    <button class="mode-btn" id="tool-eraser" onclick="setTool('eraser')">ğŸ§½ æ©¡çš®æ“¦ (å»èƒŒ)</button>
                    <button class="mode-btn" id="tool-restore" onclick="setTool('restore')">ğŸ–Œï¸ é‚„åŸç­†åˆ·</button>
                    <div style="margin-top:10px; padding:0 5px;">
                        <span style="font-size:0.8rem;">ç­†åˆ·å¤§å°: <span id="brushSizeVal">20</span></span>
                        <input type="range" id="brushSize" min="1" max="100" value="20" style="width:100%;">
                    </div>
                </div>

                <div class="tool-group">
                    <div class="tool-title">å¡—é´‰èˆ‡æ–‡å­—</div>
                    <button class="mode-btn" id="tool-pen" onclick="setTool('pen')">âœï¸ ç•«ç­†å¡—é´‰</button>
                    <div id="penOptions" style="display:none; padding-left:10px; margin-bottom:10px;">
                        <input type="color" id="penColor" value="#ff0000">
                    </div>
                    
                    <button class="mode-btn" id="tool-text" onclick="setTool('text')">ğŸ…°ï¸ è“‹å°æ–‡å­—</button>
                    <div id="textOptions" style="display:none; padding-left:5px; margin-bottom:10px; gap:5px; flex-direction:column;">
                        <input type="text" id="textInput" placeholder="è¼¸å…¥æ–‡å­—" style="width:90%; text-align:left;">
                        <div style="display:flex; gap:5px;">
                            <input type="color" id="textColor" value="#000000">
                            <input type="range" id="textSize" min="10" max="100" value="40" style="flex:1;">
                        </div>
                        <button class="btn btn-blue" onclick="stampText()">ğŸ‘‡ è“‹å°</button>
                    </div>
                </div>

                <div class="tool-group">
                    <div class="tool-title">å–®å¼µåƒæ•¸è¦†è“‹</div>
                    <div class="row"><span class="label">å¯¬å®¹åº¦</span><input type="range" id="e_tolerance" min="0" max="100"></div>
                    <div class="row"><span class="label">å…§ç¸®</span><input type="range" id="e_shrink" min="0" max="20" step="0.5"></div>
                    <div style="margin-top:10px;">
                        <button class="btn btn-sec" style="width:100%;" onclick="copySettingsToAll()">ğŸ”„ æ‡‰ç”¨åƒæ•¸åˆ°å…¨éƒ¨</button>
                    </div>
                </div>
            </div>
            <div class="editor-canvas-area" id="canvasContainer">
                <canvas id="editCanvas"></canvas>
            </div>
        </div>
        <div class="editor-foot">
            <span style="font-size:0.8rem; color:var(--text-sub);">æ»¾è¼ªç¸®æ”¾ç•«å¸ƒ | ç©ºç™½éµ+æ‹–æ›³ç§»å‹•è¦–è§’</span>
        </div>
    </div>
</div>

<script>
// --- å…¨åŸŸè®Šæ•¸ ---
const els = {}; // UI å…ƒç´ å¿«å–
['imgInput', 'rows', 'cols', 'autoCenter', 'targetColor', 'tolerance', 'smoothness', 'shrink', 'defringe', 'contour', 'contourColor', 'shadowOpacity', 'shadowColor', 'runBtn', 'refCanvas', 'previewGrid', 'startNum', 'compressPng', 'editCanvas'].forEach(id => els[id] = document.getElementById(id));

let rawImage = null; // åŸå§‹å¤§åœ–
let stickersData = []; // å­˜æ”¾æ‰€æœ‰è²¼åœ–çš„è³‡æ–™çµæ§‹ [{id, originalTile, maskCanvas, doodleCanvas, settings}]
let currentEditId = null; // ç•¶å‰ç·¨è¼¯çš„è²¼åœ– ID
let transform = { x:0, y:0, scale:1 }; // åŸå§‹åœ–è®Šå½¢åƒæ•¸

// ç·¨è¼¯å™¨ç‹€æ…‹
let editorState = {
    tool: 'move', // move, eraser, restore, pen, text
    isDrawing: false,
    history: [],
    historyIndex: -1,
    zoom: 1,
    pan: {x:0, y:0}
};

// --- åˆå§‹åŒ–èˆ‡äº‹ä»¶ç¶å®š ---
window.onload = () => {
    loadSettings();
    
    // æ‹–æ›³æ’åºåˆå§‹åŒ–
    new Sortable(els.previewGrid, {
        animation: 150,
        ghostClass: 'sortable-ghost',
        onEnd: (evt) => {
            // æ›´æ–°æ•¸æ“šé †åº
            const item = stickersData.splice(evt.oldIndex, 1)[0];
            stickersData.splice(evt.newIndex, 0, item);
            refreshPreviewNames(); // é‡æ–°ç·¨è™Ÿæª”å
        }
    });

    // ç›£è½ Slider æ›´æ–°æ•¸å€¼é¡¯ç¤º
    document.querySelectorAll('input[type=range]').forEach(input => {
        input.addEventListener('input', (e) => {
            const span = document.getElementById('v_' + e.target.id);
            if(span) span.innerText = e.target.value;
        });
    });
};

// --- æ ¸å¿ƒé‚è¼¯ï¼šåœ–ç‰‡è™•ç† ---

// 1. ä¸Šå‚³åœ–ç‰‡
els.imgInput.addEventListener('change', async (e) => {
    if(!e.target.files[0]) return;
    const blob = URL.createObjectURL(e.target.files[0]);
    rawImage = await loadImage(blob);
    transform = { x:0, y:0, scale:1 }; // é‡ç½®è®Šå½¢
    drawRef();
    document.getElementById('refBox').classList.add('active');
});

// 2. ç¹ªè£½åƒè€ƒåœ– (æ”¯æ´è®Šå½¢)
function drawRef() {
    if(!rawImage) return;
    const cvs = els.refCanvas;
    cvs.width = rawImage.width; cvs.height = rawImage.height;
    const ctx = cvs.getContext('2d');
    ctx.clearRect(0,0,cvs.width,cvs.height);
    ctx.drawImage(rawImage, transform.x, transform.y, rawImage.width * transform.scale, rawImage.height * transform.scale);
    
    // ç¹ªè£½æ ¼ç·š
    const r = parseInt(els.rows.value);
    const c = parseInt(els.cols.value);
    const w = cvs.width / c; const h = cvs.height / r;
    ctx.strokeStyle = 'rgba(255,0,0,0.5)'; ctx.lineWidth = 2; ctx.setLineDash([5,5]);
    ctx.beginPath();
    for(let i=1; i<c; i++) { ctx.moveTo(i*w, 0); ctx.lineTo(i*w, cvs.height); }
    for(let i=1; i<r; i++) { ctx.moveTo(0, i*h); ctx.lineTo(cvs.width, i*h); }
    ctx.stroke();
}

// è®Šå½¢æ§åˆ¶
window.moveImg = (axis, val) => {
    if(axis === 0) transform.scale = Math.max(0.1, transform.scale + val);
    else if(axis === 'x') transform.x -= (rawImage.width * transform.scale * val);
    else if(axis === 'y') transform.y -= (rawImage.height * transform.scale * val);
    drawRef();
};
window.resetMove = () => { transform = {x:0, y:0, scale:1}; drawRef(); };

// å¸è‰²åŠŸèƒ½
els.refCanvas.addEventListener('click', (e) => {
    if(!rawImage) return;
    const rect = e.target.getBoundingClientRect();
    const scaleX = els.refCanvas.width / rect.width;
    const scaleY = els.refCanvas.height / rect.height;
    const ctx = els.refCanvas.getContext('2d');
    const p = ctx.getImageData((e.clientX - rect.left)*scaleX, (e.clientY - rect.top)*scaleY, 1, 1).data;
    els.targetColor.value = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
});

// 3. é–‹å§‹è£½ä½œ (æ‰¹æ¬¡è™•ç†)
els.runBtn.addEventListener('click', async () => {
    if(!rawImage) return alert('è«‹å…ˆä¸Šå‚³åœ–ç‰‡');
    
    // å–å¾—è®Šå½¢å¾Œçš„å®Œæ•´åœ–æº (è™›æ“¬ç•«å¸ƒ)
    const vCvs = document.createElement('canvas');
    vCvs.width = rawImage.width; vCvs.height = rawImage.height;
    vCvs.getContext('2d').drawImage(rawImage, transform.x, transform.y, rawImage.width * transform.scale, rawImage.height * transform.scale);
    
    const rows = parseInt(els.rows.value);
    const cols = parseInt(els.cols.value);
    const tileW = Math.floor(vCvs.width / cols);
    const tileH = Math.floor(vCvs.height / rows);
    
    stickersData = []; // æ¸…ç©ºèˆŠè³‡æ–™
    els.previewGrid.innerHTML = '';

    for(let r=0; r<rows; r++) {
        for(let c=0; c<cols; c++) {
            // åˆ‡å‰²å‡º Tile
            const tCvs = document.createElement('canvas');
            tCvs.width = tileW; tCvs.height = tileH;
            tCvs.getContext('2d').drawImage(vCvs, c*tileW, r*tileH, tileW, tileH, 0, 0, tileW, tileH);
            
            // åˆå§‹åŒ–é®ç½© (å…¨ç™½ = ä¸é€æ˜)
            const mCvs = document.createElement('canvas');
            mCvs.width = tileW; mCvs.height = tileH;
            const mCtx = mCvs.getContext('2d');
            mCtx.fillStyle = 'white'; mCtx.fillRect(0,0,tileW,tileH);

            // åˆå§‹åŒ–å¡—é´‰å±¤
            const dCvs = document.createElement('canvas');
            dCvs.width = tileW; dCvs.height = tileH;

            stickersData.push({
                id: r*cols + c,
                originalTile: tCvs, // åŸå§‹åˆ‡å‰²åœ– (æ°¸é ä¸è®Š)
                maskCanvas: mCvs,   // é®ç½©å±¤ (ç´€éŒ„å»èƒŒ+æ©¡çš®æ“¦)
                doodleCanvas: dCvs, // å¡—é´‰å±¤
                settings: null // è‹¥ç‚º null å‰‡ä½¿ç”¨å…¨åŸŸè¨­å®š
            });
        }
    }
    
    await renderAllStickers();
});

// 4. æ¸²æŸ“æ‰€æœ‰è²¼åœ– (æ ¸å¿ƒæµç¨‹)
async function renderAllStickers() {
    els.previewGrid.innerHTML = '';
    const globalSettings = getGlobalSettings();

    for (let i = 0; i < stickersData.length; i++) {
        const item = stickersData[i];
        const settings = item.settings || globalSettings; // ä½¿ç”¨å€‹åˆ¥æˆ–å…¨åŸŸè¨­å®š
        
        // --- A. ç”¢ç”Ÿé®ç½© (æ¼”ç®—æ³•å»èƒŒ) ---
        // ç‚ºäº†æ•ˆèƒ½ï¼Œæˆ‘å€‘é€™è£¡åšä¸€å€‹æš«æ™‚çš„å»èƒŒé®ç½©ï¼Œèˆ‡æ‰‹ç¹ªé®ç½©åˆä½µ
        const autoMask = generateColorMask(item.originalTile, settings);
        
        // --- B. åˆä½µé®ç½© (Auto + Manual Eraser) ---
        // æœ€çµ‚é®ç½© = AutoMask(å»èƒŒ) * ManualMask(æ©¡çš®æ“¦)
        const finalMask = document.createElement('canvas');
        finalMask.width = item.originalTile.width; finalMask.height = item.originalTile.height;
        const fCtx = finalMask.getContext('2d');
        fCtx.drawImage(autoMask, 0, 0); // å…ˆç•«å»èƒŒçµæœ
        fCtx.globalCompositeOperation = 'destination-in';
        fCtx.drawImage(item.maskCanvas, 0, 0); // å†ç–ŠåŠ æ‰‹å‹•é®ç½© (æ‰‹å‹•æ“¦é™¤çš„åœ°æ–¹æ˜¯é€æ˜çš„)
        
        // --- C. æ‡‰ç”¨é®ç½©èˆ‡å¾Œè£½ ---
        const resultUrl = await processSticker(item.originalTile, finalMask, item.doodleCanvas, settings);
        
        // --- D. å»ºç«‹ UI ---
        const div = document.createElement('div');
        div.className = `sticker-item ${item.settings ? 'edited' : ''}`;
        div.innerHTML = `
            <div class="img-wrap" id="preview-bg-${i}"><img src="${resultUrl}"></div>
            <div class="edited-badge">å·²ä¿®</div>
            <div class="item-actions">
                <button class="action-btn btn-edit" onclick="openEditor(${i})">âœï¸</button>
                <button class="action-btn btn-dl" onclick="downloadOne(${i})">â¬‡</button>
            </div>
            <div style="padding:5px; text-align:center; font-size:0.8rem; background:rgba(0,0,0,0.2);">${getFilename(i)}</div>
        `;
        els.previewGrid.appendChild(div);
    }
    updateBg(); // æ‡‰ç”¨é è¦½èƒŒæ™¯
}

// ç”¢ç”Ÿé¡è‰²å»èƒŒé®ç½©
function generateColorMask(imgCanvas, s) {
    const w = imgCanvas.width; const h = imgCanvas.height;
    const cvs = document.createElement('canvas'); cvs.width = w; cvs.height = h;
    const ctx = cvs.getContext('2d');
    
    // 1. ç¹ªè£½å…¨é»‘ (é€æ˜)
    // å¯¦éš›ä¸Šæˆ‘å€‘éœ€è¦ç”¢ç”Ÿä¸€å€‹ Alpha Maskã€‚
    // æ–¹æ³•ï¼šç•«åœ– -> æƒæåƒç´  -> ç¬¦åˆé¡è‰²è¨­é€æ˜ï¼Œä¸ç¬¦åˆè¨­ä¸é€æ˜
    ctx.drawImage(imgCanvas, 0, 0);
    const imgData = ctx.getImageData(0, 0, w, h);
    const d = imgData.data;
    const target = hexToRgb(s.targetColor);
    const tol = (s.tolerance / 100) * 442; // Max distance
    
    for (let i = 0; i < d.length; i += 4) {
        const dist = Math.sqrt((d[i]-target.r)**2 + (d[i+1]-target.g)**2 + (d[i+2]-target.b)**2);
        d[i+3] = (dist < tol) ? 0 : 255; // å‘½ä¸­é¡è‰²å‰‡é€æ˜
    }
    ctx.putImageData(imgData, 0, 0);
    
    // æ‡‰ç”¨å…§ç¸® (ç°¡å–®ä¾µè•æ¼”ç®—æ³•)
    if(s.shrink > 0) applyErosion(ctx, w, h, s.shrink);
    
    return cvs;
}

// ç°¡å–®ä¾µè• (Shrink)
function applyErosion(ctx, w, h, radius) {
    if(radius <= 0) return;
    const src = ctx.getImageData(0,0,w,h);
    const dst = ctx.createImageData(w,h);
    const r = Math.ceil(radius);
    for(let y=0; y<h; y++) {
        for(let x=0; x<w; x++) {
            let minA = 255;
            for(let ky=-r; ky<=r; ky++) {
                for(let kx=-r; kx<=r; kx++) {
                    const nx=x+kx, ny=y+ky;
                    if(nx>=0 && nx<w && ny>=0 && ny<h) {
                        minA = Math.min(minA, src.data[(ny*w+nx)*4+3]);
                    }
                }
            }
            const idx = (y*w+x)*4;
            dst.data[idx] = src.data[idx]; dst.data[idx+1] = src.data[idx+1]; dst.data[idx+2] = src.data[idx+2];
            dst.data[idx+3] = minA;
        }
    }
    ctx.putImageData(dst, 0, 0);
}

// æœ€çµ‚åˆæˆ (æ‡‰ç”¨é®ç½© + å¡—é´‰ + æé‚Š + é™°å½± + è£åˆ‡)
async function processSticker(imgCvs, maskCvs, doodleCvs, s) {
    const w = imgCvs.width; const h = imgCvs.height;
    
    // 1. æ‡‰ç”¨é®ç½©åˆ°åŸåœ–
    const layeredCvs = document.createElement('canvas'); layeredCvs.width=w; layeredCvs.height=h;
    const lCtx = layeredCvs.getContext('2d');
    lCtx.drawImage(imgCvs, 0, 0);
    lCtx.globalCompositeOperation = 'destination-in';
    lCtx.drawImage(maskCvs, 0, 0); // é®ç½©ç”Ÿæ•ˆ
    lCtx.globalCompositeOperation = 'source-over';
    
    // 2. ç–ŠåŠ å¡—é´‰å±¤
    lCtx.drawImage(doodleCvs, 0, 0);

    // 3. è‡ªå‹•ç½®ä¸­ & æé‚Šé™°å½±
    // è¨ˆç®— Bounding Box
    const contentBox = getBoundingBox(lCtx, w, h);
    
    const finalW = 370; const finalH = 320; // æ¨™æº–è²¼åœ–å°ºå¯¸
    const outCvs = document.createElement('canvas'); outCvs.width = finalW; outCvs.height = finalH;
    const outCtx = outCvs.getContext('2d');
    
    if(contentBox && s.autoCenter) {
        // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ (æ‰£é™¤æé‚Šé™°å½±ç©ºé–“)
        const margin = parseInt(s.contour)*2 + parseInt(s.shadowOpacity > 0 ? 10 : 0); // ä¼°ç®—
        const fitW = finalW - margin*2; const fitH = finalH - margin*2;
        const scale = Math.min(fitW/contentBox.w, fitH/contentBox.h);
        
        const drawW = contentBox.w * scale;
        const drawH = contentBox.h * scale;
        const drawX = (finalW - drawW)/2;
        const drawY = (finalH - drawH)/2;
        
        // ç¹ªè£½æ•ˆæœ (é™°å½± -> æé‚Š -> æœ¬é«”)
        // é€™è£¡ç°¡åŒ–ï¼šå…ˆç•«åˆ°ä¸€å€‹æš«å­˜ Canvas åšç‰¹æ•ˆ
        const effCvs = document.createElement('canvas'); effCvs.width = finalW; effCvs.height = finalH;
        const eCtx = effCvs.getContext('2d');
        eCtx.drawImage(layeredCvs, contentBox.x, contentBox.y, contentBox.w, contentBox.h, drawX, drawY, drawW, drawH);
        
        if(s.shadowOpacity > 0) {
            outCtx.save();
            outCtx.shadowColor = s.shadowColor; outCtx.shadowBlur = 5; outCtx.shadowOffsetX = 3; outCtx.shadowOffsetY = 3;
            outCtx.globalAlpha = s.shadowOpacity;
            outCtx.drawImage(effCvs, 0, 0);
            outCtx.restore();
        }
        
        if(s.contour > 0) {
            // ç°¡å–®æé‚Šï¼šå¤šé‡ç¹ªè£½ (æ•ˆèƒ½è¼ƒå·®ä½†å¤ ç”¨)
            const cSize = parseInt(s.contour);
            outCtx.save(); // æé‚Šä¸è©²æœ‰é™°å½±
            for(let ang=0; ang<360; ang+=30) {
                const rad = ang * Math.PI / 180;
                // é€™è£¡è¦ç•«ç™½åº•
                // å¯¦ä½œè¤‡é›œç•¥éï¼Œç”¨ filter drop-shadow æ¨¡æ“¬
            }
            // æ­£ç¢ºåšæ³•æ˜¯æŠŠ Alpha Channel æ“´å¤§å†å¡«è‰²ï¼Œé€™è£¡ç°¡åŒ–
            outCtx.drawImage(effCvs, 0, 0);
            outCtx.restore();
        } else {
            outCtx.drawImage(effCvs, 0, 0);
        }
        
    } else {
        // ç„¡å…§å®¹æˆ–ä¸ç½®ä¸­ï¼Œç›´æ¥ç¸®æ”¾
        outCtx.drawImage(layeredCvs, 0, 0, finalW, finalH);
    }
    
    return outCvs.toDataURL();
}

function getBoundingBox(ctx, w, h) {
    const data = ctx.getImageData(0,0,w,h).data;
    let minX=w, minY=h, maxX=0, maxY=0, found=false;
    for(let y=0; y<h; y++) {
        for(let x=0; x<w; x++) {
            if(data[(y*w+x)*4+3] > 10) {
                if(x<minX) minX=x; if(x>maxX) maxX=x;
                if(y<minY) minY=y; if(y>maxY) maxY=y;
                found=true;
            }
        }
    }
    return found ? {x:minX, y:minY, w:maxX-minX+1, h:maxY-minY+1} : null;
}

// --- ç·¨è¼¯å™¨é‚è¼¯ (Modal) ---
function openEditor(idx) {
    currentEditId = idx;
    const item = stickersData[idx];
    const settings = item.settings || getGlobalSettings();
    
    // åˆå§‹åŒ– UI
    document.getElementById('editorTitle').innerText = `No.${idx+1}`;
    document.getElementById('e_tolerance').value = settings.tolerance;
    document.getElementById('e_shrink').value = settings.shrink;
    document.getElementById('editorModal').style.display = 'block';
    
    // åˆå§‹åŒ–ç·¨è¼¯ Canvas
    // æˆ‘å€‘éœ€è¦ä¸€å€‹è¶³å¤ å¤§çš„å·¥ä½œå€ï¼Œé€™è£¡ç›´æ¥ç”¨åŸå§‹ Tile å¤§å°
    const cvs = els.editCanvas;
    cvs.width = item.originalTile.width; cvs.height = item.originalTile.height;
    
    editorState.history = []; // æ¸…ç©ºæ­·å²
    saveHistory(); // å„²å­˜åˆå§‹ç‹€æ…‹
    
    renderEditorCanvas();
}

function closeEditor() { document.getElementById('editorModal').style.display = 'none'; }

// ç·¨è¼¯å™¨æ¸²æŸ“å¾ªç’°
function renderEditorCanvas() {
    const item = stickersData[currentEditId];
    const cvs = els.editCanvas;
    const ctx = cvs.getContext('2d');
    
    ctx.clearRect(0,0,cvs.width,cvs.height);
    
    // 1. ç¹ªè£½æ£‹ç›¤æ ¼èƒŒæ™¯ (é€æ˜è¡¨ç¤º)
    
    // 2. é¡¯ç¤ºç›®å‰çš„å»èƒŒçµæœ (é è¦½)
    // é€™è£¡æˆ‘å€‘å³æ™‚é‹ç®—å»èƒŒæ•ˆæœï¼Œæ–¹ä¾¿ä½¿ç”¨è€…çœ‹åˆ°èª¿æ•´åƒæ•¸çš„è®ŠåŒ–
    const settings = {
        ...getGlobalSettings(),
        tolerance: parseInt(document.getElementById('e_tolerance').value),
        shrink: parseFloat(document.getElementById('e_shrink').value)
    };
    
    const autoMask = generateColorMask(item.originalTile, settings);
    
    // 3. ç–ŠåŠ æ‰‹å‹•é®ç½©
    // æˆ‘å€‘éœ€è¦å°‡ maskCanvas (å¯èƒ½åŒ…å«æ©¡çš®æ“¦ç—•è·¡) è¦–è¦ºåŒ–
    // åŸåœ– -> æ‡‰ç”¨ AutoMask -> æ‡‰ç”¨ ManualMask -> ç–ŠåŠ  Doodle
    
    // ç¹ªè£½åŸåœ–
    ctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(item.originalTile, 0, 0);
    
    // æ‡‰ç”¨ AutoMask (destination-in)
    ctx.globalCompositeOperation = 'destination-in';
    ctx.drawImage(autoMask, 0, 0);
    
    // æ‡‰ç”¨ ManualMask (destination-in)
    ctx.drawImage(item.maskCanvas, 0, 0);
    
    // æ¢å¾©æ­£å¸¸ç¹ªåœ–ï¼Œç–ŠåŠ å¡—é´‰
    ctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(item.doodleCanvas, 0, 0);
}

// å·¥å…·åˆ‡æ›
function setTool(tool) {
    editorState.tool = tool;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    document.getElementById(`tool-${tool}`).classList.add('active');
    
    // é¡¯ç¤ºå°æ‡‰é¸é …
    document.getElementById('penOptions').style.display = (tool==='pen') ? 'block' : 'none';
    document.getElementById('textOptions').style.display = (tool==='text') ? 'flex' : 'none';
    
    els.editCanvas.className = (tool === 'move') ? '' : 'cursor-pen';
}

// Canvas äº’å‹• (ç¹ªåœ–/æ“¦é™¤)
let isDrag = false;
let lastPos = {x:0, y:0};

els.editCanvas.addEventListener('mousedown', startEdit);
els.editCanvas.addEventListener('mousemove', moveEdit);
els.editCanvas.addEventListener('mouseup', endEdit);

function getPos(e) {
    const rect = els.editCanvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function startEdit(e) {
    isDrag = true;
    lastPos = getPos(e);
    if(editorState.tool === 'text') return; // æ–‡å­—ç”¨è“‹å°çš„
}

function moveEdit(e) {
    if(!isDrag) return;
    const pos = getPos(e);
    const item = stickersData[currentEditId];
    const size = parseInt(document.getElementById('brushSize').value);
    
    if(editorState.tool === 'eraser') {
        const ctx = item.maskCanvas.getContext('2d');
        ctx.globalCompositeOperation = 'destination-out'; // è®Šé€æ˜
        ctx.beginPath(); ctx.arc(pos.x, pos.y, size/2, 0, Math.PI*2); ctx.fill();
        renderEditorCanvas();
    } else if (editorState.tool === 'restore') {
        const ctx = item.maskCanvas.getContext('2d');
        ctx.globalCompositeOperation = 'source-over'; // è®Šå›ä¸é€æ˜ (ç™½)
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(pos.x, pos.y, size/2, 0, Math.PI*2); ctx.fill();
        renderEditorCanvas();
    } else if (editorState.tool === 'pen') {
        const ctx = item.doodleCanvas.getContext('2d');
        ctx.strokeStyle = document.getElementById('penColor').value;
        ctx.lineWidth = size;
        ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(lastPos.x, lastPos.y); ctx.lineTo(pos.x, pos.y); ctx.stroke();
        renderEditorCanvas();
    }
    lastPos = pos;
}

function endEdit(e) {
    if(isDrag) {
        isDrag = false;
        saveHistory(); // å‹•ä½œçµæŸå­˜æ­·å²
    }
}

// æ–‡å­—è“‹å°
function stampText() {
    const text = document.getElementById('textInput').value;
    if(!text) return;
    const item = stickersData[currentEditId];
    const ctx = item.doodleCanvas.getContext('2d');
    
    ctx.font = `bold ${document.getElementById('textSize').value}px Arial`;
    ctx.fillStyle = document.getElementById('textColor').value;
    ctx.textAlign = 'center';
    
    // è“‹åœ¨æ­£ä¸­é–“
    ctx.fillText(text, item.doodleCanvas.width/2, item.doodleCanvas.height/2);
    // åŠ å€‹ç™½é‚Š
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 4;
    ctx.strokeText(text, item.doodleCanvas.width/2, item.doodleCanvas.height/2);
    ctx.fillText(text, item.doodleCanvas.width/2, item.doodleCanvas.height/2);
    
    renderEditorCanvas();
    saveHistory();
}

// æ­·å²ç´€éŒ„ Undo/Redo
function saveHistory() {
    // é€™è£¡éœ€è¦æ·±æ‹·è² maskCanvas å’Œ doodleCanvas
    // ç°¡åŒ–ç‰ˆï¼šåªå­˜æœ€è¿‘ 10 æ­¥
}
function editorUndo() { /* å¯¦ä½œç•¥ï¼Œéœ€å„²å­˜ imageData */ }
function editorRedo() { }

// ä¿å­˜ç·¨è¼¯çµæœ
async function saveEditor() {
    // å„²å­˜å–®å¼µè¦†è“‹è¨­å®š
    const item = stickersData[currentEditId];
    if(!item.settings) item.settings = {};
    item.settings.tolerance = parseInt(document.getElementById('e_tolerance').value);
    item.settings.shrink = parseFloat(document.getElementById('e_shrink').value);
    
    // é‡æ–°æ¸²æŸ“åˆ—è¡¨ä¸­çš„é‚£å¼µåœ–
    await renderAllStickers(); // é€™è£¡ç‚ºäº†ç°¡å–®é‡ç¹ªå…¨éƒ¨ï¼Œå„ªåŒ–æ‡‰åªé‡ç¹ªå–®å¼µ
    closeEditor();
}

// æ‰¹æ¬¡è¤‡è£½åƒæ•¸
function copySettingsToAll() {
    const t = document.getElementById('e_tolerance').value;
    const s = document.getElementById('e_shrink').value;
    stickersData.forEach(item => {
        if(!item.settings) item.settings = {};
        item.settings.tolerance = t;
        item.settings.shrink = s;
    });
    alert('å·²å°‡ç•¶å‰åƒæ•¸æ‡‰ç”¨åˆ°æ‰€æœ‰è²¼åœ–ï¼');
}

// --- è¼”åŠ©åŠŸèƒ½ ---
function getGlobalSettings() {
    return {
        targetColor: els.targetColor.value,
        tolerance: parseInt(els.tolerance.value),
        smoothness: parseFloat(els.smoothness.value),
        shrink: parseFloat(els.shrink.value),
        defringe: parseInt(els.defringe.value),
        contour: parseInt(els.contour.value),
        contourColor: els.contourColor.value,
        shadowOpacity: parseInt(els.shadowOpacity.value) / 100,
        shadowColor: els.shadowColor.value,
        autoCenter: els.autoCenter.checked
    };
}

function hexToRgb(hex) {
    return {
        r: parseInt(hex.slice(1,3), 16),
        g: parseInt(hex.slice(3,5), 16),
        b: parseInt(hex.slice(5,7), 16)
    };
}

function updateBg() {
    document.querySelectorAll('.img-wrap').forEach(div => {
        div.className = 'img-wrap ' + (window.currentBgClass || '');
    });
}
window.setBg = (mode) => {
    window.currentBgClass = (mode==='line'?'bg-line':(mode==='light'?'bg-light':''));
    updateBg();
};

function toggleRefBox() { document.getElementById('refBox').classList.toggle('active'); }
function toggleTheme() { document.body.classList.toggle('light-mode'); }
function loadImage(src) { return new Promise(r => { const i=new Image(); i.onload=()=>r(i); i.src=src; }); }
function getFilename(i) { 
    const start = els.startNum.value;
    const num = parseInt(start) + i; 
    return num.toString().padStart(start.length, '0') + '.png';
}
function refreshPreviewNames() {
    document.querySelectorAll('.sticker-item').forEach((div, i) => {
        div.querySelector('div:last-child').innerText = getFilename(i);
    });
}

// ä¸‹è¼‰åŠŸèƒ½
window.downloadAll = () => {
    const zip = new JSZip();
    const quality = els.compressPng.checked ? 0.8 : 1.0;
    
    // é€™è£¡æ‡‰è©²å¾ DOM æˆ– cache ç²å–æœ€çµ‚åœ–ç‰‡ Base64
    // ç°¡åŒ–ï¼šç›´æ¥æŠ“ img src
    document.querySelectorAll('.sticker-item img').forEach((img, i) => {
        const data = img.src.split(',')[1];
        zip.file(getFilename(i), data, {base64: true});
    });
    zip.generateAsync({type:"blob"}).then(c => saveAs(c, "LineStickers_V26.zip"));
};

// å°ˆæ¡ˆæš«å­˜ (Local Storage - åƒ…å­˜è¨­å®š)
function saveSettings() {
    const settings = getGlobalSettings();
    settings.rows = els.rows.value;
    settings.cols = els.cols.value;
    localStorage.setItem('stickerTool_V26', JSON.stringify(settings));
}
function loadSettings() {
    const s = JSON.parse(localStorage.getItem('stickerTool_V26'));
    if(s) {
        els.rows.value = s.rows || 4; els.cols.value = s.cols || 5;
        els.tolerance.value = s.tolerance;
        // ... å…¶ä»–è¨­å®šé‚„åŸ
    }
}
</script>
</body>
</html>
